"use client"
import React, { useState, useEffect, useRef } from "react"
import { motion } from "framer-motion"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import Icon from "@/components/icon"
interface CodeParserProps {
  data?: string
  fileName?: "package.json" | "requirements.txt"
}

const sampleData = `{
  "name": "repotalent",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbo",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@ai-sdk/openai": "^1.0.6",
    "@hookform/resolvers": "^3.9.1",
    "@radix-ui/react-checkbox": "^1.1.2",
    "@radix-ui/react-dialog": "^1.1.2",
    "@radix-ui/react-label": "^2.1.0",
    "@radix-ui/react-select": "^2.1.2",
    "@radix-ui/react-slot": "^1.1.0",
    "@supabase/ssr": "^0.5.2",
    "@supabase/supabase-js": "^2.46.2",
    "ai": "^4.0.11",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "framer-motion": "^11.13.1",
    "input-otp": "^1.4.1",
    "lucide-react": "^0.465.0",
    "next": "15.0.3",
    "next-themes": "^0.4.3",
    "react": "^18",
    "react-dom": "^18",
    "react-hook-form": "^7.53.2",
    "shadcn-dropzone": "^0.2.1",
    "sonner": "^1.7.0",
    "tailwind-merge": "^2.5.5",
    "tailwindcss-animate": "^1.0.7",
    "zod": "^3.23.8"
  },
  "devDependencies": {
    "@types/node": "^20",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "eslint": "^8",
    "eslint-config-next": "14.2.16",
    "postcss": "^8",
    "tailwindcss": "^3.4.16",
    "typescript": "^5"
  }
}`

function parsePackageJson(file: string) {
  return JSON.parse(file)
}

// Add these helper functions outside the component
const getPackageBase = (pkg: string): string => {
  const scopedPackageRegex = /@[^/]+\//
  const match = pkg.match(scopedPackageRegex)
  if (match) {
    return match[0]
  }
  return pkg.split("-")[0]
}

const generateGroupColor = (index: number): string => {
  const colors = [
    "text-blue-500",
    "text-green-500",
    "text-purple-500",
    "text-orange-500",
    "text-rose-500",
    "text-yellow-500",
    "text-cyan-500",
    "text-indigo-500",
    "text-pink-500",
  ]
  return colors[index % colors.length]
}

const CodeParser = ({
  data = sampleData,
  fileName = "package.json",
}: CodeParserProps) => {
  const fileData = fileName === "package.json" ? parsePackageJson(data) : null
  const [intialAnimationDone, setIntialAnimationDone] = useState(false)
  const [renderedCount, setRenderedCount] = useState(0)
  const [highlightedItems, setHighlightedItems] = useState<Set<string>>(
    new Set()
  )
  const [currentPaths, setCurrentPaths] = useState<string[]>([])

  const dotRefs = useRef<Record<string, HTMLDivElement | null>>({})

  // Move getGroupColor to component level
  const getGroupColor = (key: string): string => {
    if (!fileData) return "bg-gray-100/50"
    const groupColors = Object.keys(fileData).reduce((acc, k) => {
      const base = getPackageBase(k)
      if (!acc[base]) {
        acc[base] = generateGroupColor(Object.keys(acc).length)
      }
      return acc
    }, {} as Record<string, string>)

    const base = getPackageBase(key)
    return groupColors[base] || "bg-gray-100/50"
  }

  const drawLines = () => {
    const svg = document.getElementById("line-svg")
    if (!svg) return

    // Clear existing lines
    while (svg.firstChild) {
      svg.removeChild(svg.firstChild)
    }

    const firstDotKey = Object.keys(dotRefs.current)[0]
    const firstDot = dotRefs.current[firstDotKey]

    if (!firstDot) return

    const firstRect = firstDot.getBoundingClientRect()
    const firstX = firstRect.left + firstRect.width / 2
    const firstY = firstRect.top + firstRect.height / 2

    Object.keys(dotRefs.current).forEach((key, index) => {
      if (index === 0) return // Skip the first dot

      const dot = dotRefs.current[key]
      if (dot) {
        const rect = dot.getBoundingClientRect()
        const x = rect.left + rect.width / 2
        const y = rect.top + rect.height / 2

        const line = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "line"
        )
        line.setAttribute("x1", firstX.toString())
        line.setAttribute("y1", firstY.toString())
        line.setAttribute("x2", x.toString())
        line.setAttribute("y2", y.toString())
        line.setAttribute("stroke", getGroupColor(key)) // Use getGroupColor to get the color
        line.setAttribute("stroke-width", "2")
        svg.appendChild(line)
      }
    })
  }

  useEffect(() => {
    if (intialAnimationDone) {
      drawLines()
    }
  }, [intialAnimationDone, currentPaths])

  useEffect(() => {
    if (intialAnimationDone && currentPaths.length > 0) {
      const highlightItems = () => {
        currentPaths.forEach((path, index) => {
          setTimeout(() => {
            setHighlightedItems((prev) => {
              const newSet = new Set(prev)
              newSet.add(path)
              return newSet
            })
          }, index * 200)
        })
      }

      highlightItems()
    }
  }, [intialAnimationDone, currentPaths])

  const calculateTotalItems = (obj: Record<string, any>): number => {
    return Object.values(obj).reduce((count, value) => {
      if (typeof value === "object") {
        return count + calculateTotalItems(value)
      }
      return count + 1
    }, 0)
  }

  const totalItems = calculateTotalItems(fileData)

  const handleAnimationComplete = () => {
    setRenderedCount((prevCount) => {
      const newCount = prevCount + 1
      if (newCount === totalItems) {
        console.log("Animation completed")
        setIntialAnimationDone(true)
      }
      return newCount
    })
  }

  const renderObject = (obj: Record<string, any>, depth = 0, path = "") => {
    const isPackageGrouped = (key: string): boolean => {
      if (!intialAnimationDone) return false
      const base = getPackageBase(key)
      return Object.keys(obj).some(
        (k) => k !== key && getPackageBase(k) === base
      )
    }

    return Object.entries(obj).map(([key, value], index) => {
      const currentPath = path ? `${path}.${key}` : key

      if (!currentPaths.includes(currentPath)) {
        setCurrentPaths((prev) => [...prev, currentPath])
      }

      const isGrouped = isPackageGrouped(key)
      const groupColor = isGrouped ? getGroupColor(key) : ""
      const isHighlighted = highlightedItems.has(currentPath)

      return (
        <motion.div
          key={key}
          initial={{ opacity: 0, x: -20 }}
          animate={{
            opacity: 1,
            x: 0,
          }}
          transition={{
            delay: index * 0.1,
            duration: 0.3,
          }}
          onAnimationComplete={handleAnimationComplete}
          style={{ marginLeft: depth * 20 }}
          className={`text-xs rounded-sm px-1 transition-colors duration-300`}
        >
          {typeof value === "object" ? (
            <div className="flex flex-col gap-2 border-primary/20 p-2 rounded-md">
              <span className="font-bold">{key}:</span> &#123;
              <div>{renderObject(value, depth + 1, currentPath)}</div>
              &#125;
            </div>
          ) : (
            <span
              className={`font-light ${
                isHighlighted ? "opacity-100" : "opacity-50"
              }`}
            >
              {key}: {value}
            </span>
          )}
          {isGrouped && (
            <motion.div
              ref={(el) => (dotRefs.current[key] = el)}
              className={`w-2 h-2 rounded-full ${groupColor}`}
              initial={{ scale: 0 }}
              animate={{ scale: 1 }}
              transition={{ delay: index * 0.1 + 0.3, duration: 0.3 }}
            />
          )}
        </motion.div>
      )
    })
  }

  if (!fileData) return null

  return (
    <Card>
      <CardHeader>
        <CardTitle>{fileName}</CardTitle>
      </CardHeader>
      <CardContent>
        <svg
          id="line-svg"
          className="absolute top-0 left-0 w-full h-full pointer-events-none"
        />
        {renderObject(fileData)}
      </CardContent>
    </Card>
  )
}

export default CodeParser
